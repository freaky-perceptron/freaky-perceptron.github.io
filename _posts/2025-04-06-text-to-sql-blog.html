---
layout: post 
title: "Building Scalable and Accurate Text-to-SQL Systems"
date: 2025-06-16
subtitles: ""
background: '/img/posts/binary.webp'
permalink: /posts/building-scalable-and-accurate-text-to-sql-systems
---

<p style="font-style: italic; color: #666; margin-bottom: 1.5rem;">This article was originally published on <a href="https://substack.com/home/post/p-166060768" target="_blank" rel="noopener noreferrer">Substack</a>.</p>

<img class="img-fluid" src="https://substackcdn.com/image/fetch/$s_!g4Ma!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe6eb9e8f-025c-4f72-a76e-0907d57e2b46_1024x1024.webp" alt="Text-to-SQL Systems">

<p>Imagine asking a question in plain English like "How has my month-on-month revenue been in this quarter?" and instantly getting a precise answer right from your company's database, supported with a nice visualization, without knowing anything about databases or how to write an SQL query. This is the promise of Text-to-SQL systems, which bridge natural language and relational databases. By translating natural language questions into structured database queries, Text-to-SQL democratizes data access, empowering non-technical users to extract meaningful and deeper insights from complex databases with ease.</p>
<p>While the concept sounds straightforward "Just let the LLM write the SQL" but the reality is far more nuanced. Human language and SQL are fundamentally mismatched.</p> 

<h3>Text-to-SQL systems are hard to build</h3>

<p>SQL is rigid, precise, and unforgiving. Natural language is ambiguous, contextual, and fluid. Bridging this gap requires more than just "translation." It demands a deep understanding of intent, schema, semantics, and the ability to navigate a minefield of technical constraints. Let's break down why this is hard:</p>

<h4>Everything should be semantically meaningful for AI to make sense of</h4>

<p>When a user asks, "Show me staff in marketing hired after 2020," the LLM must:</p>

<ul>
<li>Map "staff" ‚Üí employee table</li>
<li>Infer "marketing" ‚Üí department_name = 'Marketing'</li>
<li>Translate "hired after 2020" ‚Üí hire_date > '2020-12-31'</li>
</ul>

<p>But what if the schema uses dept_id instead of department_name, or the user says "team" instead of "staff"? Misinterpretations here lead to queries that either fail or return garbage.</p>

<h4>SQL requires precision</h4>

<p>Unlike a chatbot that can approximate an answer, SQL demands absolute correctness. A missing JOIN, an incorrect GROUP BY, or a misplaced HAVING clause doesn't just degrade results; it crashes the query. For example:</p>

<p>User asks: "Total sales per region last year."</p>

<p>The AI must:</p>

<ul>
<li>Join sales, regions, and time tables</li>
<li>Aggregate with SUM() and GROUP BY region</li>
<li>Filter dates to the previous year, requiring the context of the current date</li>
</ul>

<p>One missed step, and the answer is wrong.</p>

<h4>Messy database schemas</h4>

<p>Real-world databases are rarely designed for LLM comprehension. Cryptic column names (e_add for "employee address"), denormalized tables, and legacy design choices turn schema mapping into a puzzle. For instance:</p>

<ul>
<li>A user's "project end date" might live in projects.end_date or assignments.termination_date, depending on the schema.</li>
<li>A query like "Who manages the sales team?" requires knowing that departments.manager_id maps to employees.employee_id, a foreign key relationship invisible in natural language.</li>
</ul>

<h4>Complexity ceiling</h4>

<p>Simple queries (e.g., filtering a single table) are manageable. But as questions grow in complexity, like "Show me employees in the sales department who joined after 2020, are working on active projects, and have had a salary increment of over 10%," the LLM must orchestrate:</p>

<ul>
<li>Multi-table joins (employee, departments, projects, salaries)</li>
<li>Subqueries to compare historical salaries</li>
<li>Date arithmetic and conditional logic</li>
</ul>

<p>Even humans struggle with such queries, and expecting AI to nail this consistently is a tall order.</p>

<h4>UX challenges</h4>

<p>When a SQL query fails, users don't get a "close enough" answer they get a database error or empty results. Imagine a non-technical user seeing:</p>

<pre><code>ERROR: syntax error at or near "WHERE"</code></pre>

<p>Or worse: a query that runs but returns the wrong data due to a logical flaw (e.g., missing DISTINCT in a count). Unlike creative writing or summarization, there's no room for "hallucination" in SQL.</p>

<h3>How Do LLMs Actually Generate SQL Queries?</h3>

<p>While Text-to-SQL systems may feel magical, their capabilities are rooted in rigorous training and structured prompting. They are typically trained and fine-tuned on benchmark datasets:</p>

<ul>
    <li>Spider: The gold standard for complexity, featuring 200+ databases and 10,000+ questions spanning healthcare, education, and more. It tests multi-table joins, nested queries, and advanced SQL logic.</li>
    <li>WikiSQL: A simpler but massive dataset (80,000+ examples) focused on single-table queries ideal for mastering basic SELECT, WHERE, and GROUP BY operations.</li>
    <li>SParC/CoSQL: Built for conversational SQL, these extensions of Spider handle multi-turn interactions (e.g., ‚ÄúNow filter those results to show only managers‚Äù).</li>
</ul>

<p>These datasets teach models to map phrases like "employees" ‚Üí staff_table and "hired after 2020" ‚Üí hire_date > '2020-12-31'.</p>

<h4>What happens under the hood?</h4>

<p>Here is a pseudocode example of how an LLM translates a user's question into a working query:</p>

<img class="img-fluid" src="https://substackcdn.com/image/fetch/$s_!ipNR!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F587814d8-880a-4adc-a934-a129fa33bd2b_1744x1376.png" alt="Text-to-SQL System Architecture">

<p>The generated SQL output might look like this:</p>

<img class="img-fluid" src="https://substackcdn.com/image/fetch/$s_!RuBH!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F54ef6d62-7faf-4974-8bd7-3072ab77a7b6_988x384.png" alt="Text-to-SQL System Architecture">
<br><br>
<h3>How to handle large schemas?</h3>

<p>When databases scale to hundreds of tables and thousands of columns, directly passing the full schema to an LLM becomes impractical. Token limits, computational costs, and irrelevant context degrade performance. The goal should be to select the most relevant subset of tables and columns based on the user's query. Here are two strategies to filter the relevant table schemas:</p>

<h4>Dynamic Schema Filter</h4>

<p>Choose an LLM with a high context length (it doesn't need to be the best model out there), sufficient to accommodate all the table schema tokens. Pass in all the table schemas and let the model identify the top-K tables and columns relevant to the user input.</p>

<img class="img-fluid" src="https://substackcdn.com/image/fetch/$s_!ipNR!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F587814d8-880a-4adc-a934-a129fa33bd2b_1744x1376.png" alt="Text-to-SQL System Architecture">

<h4>Dynamic schema retriever with RAG</h4>

<p>This method provides LLMs with precise, contextual schema knowledge without making it bloated with all the schema tokens.</p>

<p>Break the schema into searchable nodes:</p>

<img class="img-fluid" src="https://substackcdn.com/image/fetch/$s_!eKg_!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F3d20f0f6-7682-4961-b416-e80eabcbb40e_1732x636.png" alt="Text-to-SQL System Architecture">

<p>At runtime, use a combination of vector search (for semantic matches) and keyword search (for exact column names like region_id) to retrieve the top-K relevant table schemas.</p>

<p>A high-accuracy embedding model is likely to be a good choice for representing schema nodes.</p>

<img class="img-fluid" src="https://substackcdn.com/image/fetch/$s_!lvA1!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc78a9044-4d25-43fe-97e8-ab12848e0029_789x726.png" alt="Text-to-SQL System Architecture">

<p>These methods will fetch you the top-K relevant table schemas ranked as per the relevancy with the user input. Now only use these ranked table schemas to generate the SQL query.</p>

<h3>Core Components of a Text-to-SQL System</h3>

<p>To build robust and reliable AI systems, it's better to keep the system predictable and structured as directed workflows. Text-to-SQL systems rely on a layered architecture to handle ambiguity, errors, and complexity. Here's how each component works in practice:</p>

<h4>Intent Classification Node</h4>

<p><strong>Purpose:</strong> Filter, categorize, and scope user queries before SQL generation.</p>

<p>Every user input first passes through this layer, which is used to determine the intent or category of the user's question. Sometimes, clusters of tables or databases may be associated with different parts of the business or service categories. If the user input falls into one of these categories, your schema scope gets drastically narrowed.</p>

<p>Occasionally, a user may provide a completely irrelevant input such as "What's the meaning of life?". In such cases, the system should not attempt to generate an SQL query, as the question has nothing to do with the schema. Instead, the system should respond politely with something like:<br>
<em>"Sorry, I cannot answer this question. I can help you with questions related to employees and the company."</em></p>

<img class="img-fluid" src="https://substackcdn.com/image/fetch/$s_!gWcT!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fca05c403-c3d4-47a6-834a-fb4a093cf4b7_734x571.png" alt="Text-to-SQL System Architecture">

<p>Once you know the category of the user input you can retrieve the relevant tables schemas and proceed ahead.</p>

<h4>Query Generation Node</h4>

<p><strong>Purpose:</strong> Convert natural language questions into accurate and executable SQL queries using the relevant schema and context.</p>

<p>Query generation is a central component in Text-to-SQL systems, responsible for transforming natural language queries into syntactically correct and semantically accurate SQL statements. The content of the system prompt here can make or break the results. This system prompt should include the filtered schema context from previous stages (table selection and intent classification), along with domain-specific business rules and conversation history.</p>

<img class="img-fluid" src="https://substackcdn.com/image/fetch/$s_!QdmA!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc46c7654-04b7-415e-b063-6f7343d07951_1558x1538.png" alt="Text-to-SQL System Architecture">

<p>Once the query is formed, you execute the LLM-generated query on the database and fetch the data. Simple, right?<br>
No.</p>

<p><strong>What if you encounter an error while fetching data?</strong></p>

<p>There are multiple things that can go wrong‚Ä¶</p>

<ul>
<li><strong>Hallucination of table or column names</strong><br>
‚Üí <code>ERROR: column "emp_name" does not exist</code></li>
<li><strong>Structural defects</strong>
<ul>
<li>Missing JOINs</li>
<li>Aggregation mismatches ‚Üí <code>ERROR: column "emp_name" must appear in GROUP BY</code></li>
<li>Incorrect window function usage ‚Üí <code>ERROR: OVER specified without PARTITION BY ORDER BY</code></li>
</ul>
</li>
<li><strong>Semantic mismatches</strong>
<ul>
<li>Date format inconsistencies (<code>'01-12-2023'</code> vs ISO <code>'2023-12-01'</code>)</li>
<li>Type conversion failures (e.g., string vs integer comparisons)</li>
<li>Ambiguous column references ‚Üí <code>ERROR: column reference is ambiguous</code></li>
</ul>
</li>
</ul>

<p>There are numerous issues that can arise during query generation, which may ultimately result in execution errors.</p>

<p>Intuitively, this suggests that there should be a systematic way to troubleshoot and correct these faulty queries.</p>

<h4>Troubleshooting Node</h4>

<p><strong>Purpose:</strong> Diagnose and fix faulty SQL queries by analyzing execution errors and regenerating corrected queries.</p>

<p>To address issues in query generation, we introduce a <strong>Troubleshooting Node</strong> that activates when a query fails during execution. This node is responsible for diagnosing and correcting faulty queries by leveraging the context of the failure. It takes the following inputs:</p>

<ul>
<li>User input</li>
<li>Database schema</li>
<li>SQL query</li>
<li>Error message</li>
</ul>

<p>Using this context, the Troubleshooting Node invokes an LLM to intelligently analyze the error and revise the SQL query. It performs this correction in a loop, retrying up to <em>n</em> times to produce a valid and accurate query.</p>

<img class="img-fluid" src="https://substackcdn.com/image/fetch/$s_!rf5q!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F9161b7c6-da1d-4e72-9eae-6e197da7abba_881x1024.png" alt="Text-to-SQL System Architecture">

<p>By introducing this node into the pipeline, the system becomes far more resilient. In most cases, this step successfully resolves the error and produces a working SQL query to fetch the desired data based on the user's input. However, if all retries fail and the issue remains unresolved, the LLM can gracefully fall back with a response like:</p>

<blockquote>
<p>Sorry, I could not find an answer to your question.</p>
</blockquote>

<p>After successfully fetching the data, you may want to present the results in a more digestible form.</p>

<h4>Summary Node</h4>

<p><strong>Purpose:</strong> Convert raw query results into a concise, human-readable response.</p>

<p>The Summary Node takes the user input and the extracted data, and prompts the LLM to generate a clear, concise summary that either directly answers the user's query or highlights key insights from the data.</p>

<img class="img-fluid" src="https://substackcdn.com/image/fetch/$s_!Un4V!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F669e530e-ef41-4b17-ab17-69841065ca7b_806x438.png" alt="Text-to-SQL System Architecture">

<p>In some cases, sending data to a closed-source LLM provider for summarization may not be preferred by the client due to privacy or compliance concerns. Additionally, if the retrieved data is too large to fit within the model's context window, you can either skip the summarization step or limit it to the first few rows.</p>

<p>In some scenarios, after fetching and possibly summarizing the data, it becomes valuable to <strong>visualize</strong> the results for better clarity and insight.</p>

<h4>Chart Generation Node</h4>

<p><strong>Purpose:</strong> Enhance the user experience by transforming structured data into intuitive visualizations.</p>

<p>This step can add a powerful layer to the user experience by converting structured data into an appropriate chart.</p>

<p>But‚Ä¶ <strong>how do you generate a chart with an LLM?</strong></p>

<p>The most intuitive approach might be to pass the entire fetched dataset into the LLM prompt and ask it to decide the chart type along with appropriate axes.</p>

<p>However, this comes with challenges:</p>

<ul>
<li>Sending raw data especially sensitive information into the LLM context may pose privacy and compliance risks.</li>
<li>Large datasets may exceed the model's token limit, leading to truncation errors.</li>
</ul>

<p><strong>So, what's the smarter approach?</strong><br>
Is it possible to generate a chart <strong>without the LLM seeing the actual data</strong>?</p>

<p>Yes; and here's how:</p>

<ul>
<li>The <code>SELECT</code> <strong>statement</strong> in the SQL query reveals the column names being fetched.</li>
<li>The <strong>database schema</strong> provides metadata about column types (e.g., numerical, categorical, datetime), which helps infer the label axis (X-axis) and value axis (Y-axis).</li>
<li>The <strong>user input</strong>, combined with the <strong>SQL query</strong>, often gives strong cues about the <strong>intended chart type</strong>.</li>
</ul>

<p>For simple charts like bar, line, or scatter plots, this basic approach works well.<br>
But what about more complex charts such as grouped bar, multi-line, or stacked bar charts?</p>

<p>To support these, design the system to allow <strong>multiple series</strong> in the chart. Each <strong>series</strong> would include a distinct <strong>label axis</strong> and a corresponding <strong>value axis</strong>.</p>

<img class="img-fluid" src="https://substackcdn.com/image/fetch/$s_!97vd!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff65b819e-18ee-449c-a95e-d82bbba1afcd_1198x670.png" alt="Text-to-SQL System Architecture">

<img class="img-fluid" src="https://substackcdn.com/image/fetch/$s_!py4T!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F04814685-15ee-4b9e-bf45-d6b141ac7ee5_942x930.png" alt="Text-to-SQL System Architecture">

<p>Make the LLM generate a <strong>chart configuration</strong> by determining the chart type, title, and series. This configuration can then be easily rendered on the frontend using any charting library like <strong>Chart.js</strong>, <strong>Highcharts</strong>, or others to present a clean and informative visualization.</p>

<p>However, the fetched data may not always be suitable for visualization. Therefore, it's advisable to introduce a <strong>decision layer</strong>, either through manual rules or with LLM assistance, to determine whether a chart should be generated at all.</p>

<h3>Overall Text-to-SQL Workflow</h3>

<p>Now that we've covered all the core components, we can structure them into the following key workflow:</p>

<p><code>User Question</code> ‚Üí <code>Intent Filter</code> ‚Üí <code>Schema Focus</code> ‚Üí <code>SQL Generation</code> ‚Üí <code>Error-Correcting Execution</code> ‚Üí <code>Enhanced Output</code></p>

<p>This represents the complete flow of a robust and reliable Text-to-SQL system.</p>

<img class="img-fluid" src="https://substackcdn.com/image/fetch/$s_!h2n0!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ffaacf2be-07bf-487e-ad15-529d299a78d4_1448x1522.png" alt="Text-to-SQL System Architecture">

<h3>Addressing Miscellaneous Challenges in Text-to-SQL Systems</h3>

<p>In this section, let's walk through some edge cases and how to handle them effectively.</p>

<h4>Handling Typos and Variations in Text Columns</h4>

<p><strong>Problem:</strong><br>
What happens when a user asks:<br>
<em>"Which project <strong>Bhaavesh</strong> is working on?"</em><br>
‚Ä¶but the actual name in the database is spelled as <strong>"Bhavesh"</strong>?</p>

<p>The SQL query generated might use a strict condition like:</p>

<pre><code>WHERE name = 'Bhaavesh'</code></pre>

<p>This would return no results due to the typo.<br>
<strong>So, what's the workaround?</strong></p>

<p><strong>Solution:</strong> If you're using PostgreSQL, the <code>pg_trgm</code> extension enables <strong>fuzzy matching</strong>.</p>

<blockquote>
<p>üí° <code>pg_trgm</code> (PostgreSQL Trigram) helps perform fast fuzzy searches by:<br>
- Breaking strings into trigrams (three-character chunks)<br>
- Comparing them for similarity scores to tolerate typos and variations</p>
</blockquote>

<img class="img-fluid" src="https://substackcdn.com/image/fetch/$s_!FY5W!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd88e54f6-1624-4d24-98db-270f2ffc7fa0_1246x492.png" alt="Text-to-SQL System Architecture">

<p>You can build a utility function to rewrite the query for <strong>text columns</strong> by replacing exact matches (<code>=</code> or <code>LIKE</code>) with <strong>fuzzy matching logic</strong> using:</p>

<ul>
<li>The <code>%</code> operator for trigram similarity</li>
<li>The <code>SIMILARITY()</code> function with a threshold (e.g., 0.8)</li>
</ul>

<p>For other databases:</p>

<ul>
<li><strong>MySQL:</strong> Use <code>SOUNDEX()</code> or a <code>LEVENSHTEIN()</code> UDF</li>
<li><strong>Fallback:</strong> Apply fuzzy matching in application code (e.g., Python)</li>
</ul>

<h4>Non-Intuitive Schema Names</h4>

<p><strong>Problem:</strong><br>
Schemas with cryptic names like <code>e_table</code> or <code>p_spec</code> confuse LLMs and hurt query generation.</p>

<p><strong>Solution:</strong> Introduce a <strong>schema mapping layer</strong>:</p>

<img class="img-fluid" src="https://substackcdn.com/image/fetch/$s_!14-9!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F38209e64-6703-4cb4-9041-c66addfe9ea5_1232x488.png" alt="Text-to-SQL System Architecture">

<ul>
<li>Gather domain knowledge about the database</li>
<li>Create <strong>semantic aliases</strong> for cryptic tables/columns</li>
<li>Let LLMs work with meaningful names and map them back to actual schema names before executing the SQL</li>
</ul>

<h4>Domain-Specific Terminologies</h4>

<p><strong>Problem:</strong> LLMs often fail to understand domain-specific jargon. For example:<br>
<em>"unmet needs = importance - satisfaction"</em> is not self-evident to an LLM.</p>

<p><strong>Solution:</strong> Inject <strong>domain rules</strong> directly into the system prompt:</p>

<img class="img-fluid" src="https://substackcdn.com/image/fetch/$s_!TqMi!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff86a7357-ee81-456e-aa1a-805990f45a83_1256x588.png" alt="Text-to-SQL System Architecture">

<pre><code>Business Rules:
- "unmet needs" = importance_score - satisfaction_score
- "active customers" = status='active' AND last_purchase_date > NOW() - INTERVAL '90 days'
- "churn risk" = (missed_payments > 2 OR engagement_score < 3)</code></pre>

<p>These rules help LLMs translate abstract phrases into actionable SQL logic.</p>

<h4>LLM Gets Confused or Lacks Reasoning</h4>

<p><strong>Problem:</strong> LLM may confuse similar tables (e.g., <code>customer_data</code> vs <code>client_records</code>) or generate queries without sufficient thought.</p>

<p><strong>Solution:</strong> Force <strong>step-by-step reasoning</strong> before query generation.</p>

<p>Use a reasoning section in the system prompt:</p>

<img class="img-fluid" src="https://substackcdn.com/image/fetch/$s_!58BB!,w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F87b61419-afae-47c2-add7-d99bbb17a515_1240x910.png" alt="Text-to-SQL System Architecture">

<p>This encourages deeper analysis and reduces brittle query generation.</p>

<h3>Final Thoughts</h3>

<p>Building a production-grade Text-to-SQL system requires much more than basic prompting. Reliability comes from well-architected pipelines:</p>

<ul>
<li><strong>Intent Filtering</strong></li>
<li><strong>Schema Selection</strong></li>
<li><strong>Query Generation</strong></li>
<li><strong>Error Handling</strong></li>
<li><strong>Summarization or Visualization</strong></li>
</ul>

<p>Each component solves a real-world challenge from vague user input to confusing schemas to broken queries.</p>

<p>The <strong>multi-node architecture</strong>, <strong>retry loops</strong>, and <strong>domain-specific knowledge injection</strong> are essential for robustness.</p>

<p>While complex, these systems can transform the way users interact with data making natural language a truly powerful interface to structured databases. With advancing LLMs and thoughtful engineering, conversational data tools are now practical for real-world deployment.</p>

